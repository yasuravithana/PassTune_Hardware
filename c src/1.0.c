
/*
20MHz crystal
timer2 interrupts at 800us
int0,1,2 enabled
portD is output
A0 is the touch input
A1 is the 'Done' switch which indicates the end of the rhythm
int_EXT is for mode switching
int_EXT1 is for restarting
*/

/*usable RAM addresses starts from 0x019 variables declared in the code starts from here*/


#include <1.0.h>

#define inputDelay 0 // To use in any case if the system reads unwanted inputs

int32 readInt(void);
void writeInt(void);
void store(void);
void check(void);
void storePassword(void);
void checkPassword(void);
void readTouch(void);
void activate(void);

int32  t=0;
int count,hit,timerReset;
int16 ramStart=0x50;
int32 *ramNow;
int32 touch,counter;
int isTouched;

// Variable declarations for functions (mainly for EEPROM write/read functions)
int32 value;
int8 i,j;
byte addressEEPROM;
byte* addressRAM;


// This timer is used to calculate time between hits
#int_TIMER2
void  TIMER2_isr(void) 
{
   if(timerReset==0)
      t++;
   else
   {
      t=0;
      timerReset=0;
   }
      
}

#int_EXT
void  EXT_isr(void) 
{
   if(READ_EEPROM(0x0)==0)
   {
      WRITE_EEPROM(0x0,1);// Marks that the system should start in 'Check Password' mode the next time it is reset.
   }
   
   else
   {
      WRITE_EEPROM(0x0,0);// Marks that the system should start in 'Store Password' mode the next time it is reset.
   }
   disable_interrupts(GLOBAL); // pPrevent from interrupting again
   for(counter=0;counter<50000;counter++)
   {
   // Delays inside interrupts disables interrupts. So this is the alternative for a delay.
   }
   reset_cpu();// This is to start agin in the new mode.
}

#int_EXT1
void  EXT1_isr(void) 
{
   reset_cpu();
}

#int_EXT2
void  EXT2_isr(void) 
{

}




void main()
{
   //ADC setup
   setup_adc(ADC_CLOCK_INTERNAL);
   setup_adc_ports(AN0);//to read the touch input
   set_adc_channel(0);
   delay_us(10);
   
   //Interrupts setup
   setup_timer_2(T2_DIV_BY_1,249,16);      //50.0 us overflow, 800 us interrupt
   enable_interrupts(INT_TIMER2);
   enable_interrupts(INT_EXT);
   enable_interrupts(INT_EXT1);
   enable_interrupts(INT_EXT2);
   enable_interrupts(GLOBAL);
   
   //Initialization of dynamic values   
   count=0;
   timerReset=0;
   t=0;
   isTouched=0;
   
   
   //Mode selection
   if(READ_EEPROM(0x0)==0)
   {
      storePassword();
   }
   
   else
   {
      checkPassword();
   }
  
}


// This function sets the variable 'isTouched' which takes 1 when touch plate is being touched
void readTouch(void)
{
      touch=read_adc();// reads the voltage of the AN0 pin
      if (touch>0x1900)
         isTouched=1;//Mark that the touch plate is being touched
      else
      {
         for(counter=0;counter<1000;counter++)//This loop is to avoid pulses generated by the body and the environment
         {
            touch=read_adc();
            if(touch>0x1900)
               return;
         }
         isTouched=0;//Mark that the touch plate is being released
      }

}

//Code for the 'Store Password' mode
void storePassword(void)
{
   output_high(pin_D4);//Indicate store mode
   ramNow=ramStart;
   
   //Wait till the user starts tapping
   while(isTouched==0)
   {
      readTouch();
      output_high(pin_D7);//test
   }
   output_low(pin_D7);//test
   timerReset=1;
   hit=1;   
   delay_ms(inputDelay);//Make sure no repititive inputs are taken
   while(true)
   {
   
      readTouch();
      if(((hit==0)&&(isTouched==1))||((hit==1)&&(isTouched==0)))//Check whether touched/released status is changed 
      {
         if(hit==1)
            hit=0;//Mark released state
         else
            hit=1;//Mark touched state
         *ramNow=t;  //Save the time period in RAM
         ramNow++;
         count++;
         timerReset=1;  //Mark that the timer needs to be reset
         delay_ms(inputDelay);//make sure no repititive inputs are taken
      }
   
      if(input(pin_A1)==1) //Check whether the user is done with entering the rhythm
      {
         store(); //Stores the array of time periods in EEPROM
         output_high(pin_D7);//test
         break;   //End the storing loop
      }    
   }
}


// Here the 'addressEEPROM' is incremented within the 'writeInt()' function.
void store(void)
{
   ramNow=ramStart;
   addressEEPROM=0x2;   //Start storing from address 0x2
   WRITE_EEPROM(0x1,count);   //Store the number of time periods
   DELAY_MS(8);
   for(j=0;j<count;j++) //Store each value in the array
   {
       value=*ramNow;
       writeInt();
       ramNow++;
   }
}


void checkPassword(void)
{
   
   output_high(pin_D5);//Indicate check mode
   ramNow=ramStart;
   
   while(isTouched==0)
   {
      readTouch();
      output_high(pin_D6);//test
   }
   output_low(pin_D6);//test
   timerReset=1;
   hit=1;
   delay_ms(inputDelay);//Make sure no repititive inputs are taken
   while(true)
   {
      readTouch();
      if(((hit==0)&&(isTouched==1))||((hit==1)&&(isTouched==0)))
      {
         if(hit==1)
            hit=0;
         else
            hit=1;
         *ramNow=t;
         ramNow++;
         count++;
         timerReset=1;
         delay_ms(inputDelay);//Make sure no repititive inputs are taken
      }
      
      if(input(pin_A1)==1)
      {      
         check();
         output_high(pin_D6);//test
         break;
      }    
   }
}


// Here the 'addressEEPROM' is incremented within the 'readInt()' function.
void check(void)
{
   ramNow=ramStart;
   addressEEPROM=0x2;
   if(READ_EEPROM(0x1)!=count)   //Rhythm doesn't match with the stored one in size
   {
      output_high(pin_D7);//light the error led
      while(true)
      {
         //wait till the user resets
      }
   }
   for(j=0;j<count;j++)
   {
       readInt();
       if((value/2>*ramNow) || (3*value/2<*ramNow))//Rhythm doesn't match with the stored one in values
       {
         output_high(pin_D7);//light the error led
         while(true)
         {
            //wait till the user resets
         }
       }
       ramNow++;
   }
   activate();//Activate external system
}

//External system activator
void activate(void)
{
   output_high(pin_D4);//test
}


// global variable 'addressEEPROM' should be set to the starting address of the int in EEPROM
int32 readInt(void)
{
   addressRAM = &value;
   for(i=0;i<4;i++)
   {
      *addressRAM = READ_EEPROM(addressEEPROM);
      addressRAM++;
      addressEEPROM++;
   }
   return value;
}

// global variable 'addressEEPROM' should be set to the starting address of the int in EEPROM and 'value' to the int to be written
void writeInt(void)
{
   addressRAM = &value;
   for(i=0;i<4;i++)
   {
      WRITE_EEPROM(addressEEPROM,*addressRAM);
      addressRAM++;
      addressEEPROM++;
      DELAY_MS(8);
   }
   
   
}
